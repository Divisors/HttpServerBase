package com.divisors.projectcuttlefish.httpserver.api;

import java.time.Duration;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * A generic class for standardizing non-blocking IO controllers, such as TCP servers, SQL connections, etc.
 * @author mailmindlin
 *
 * @param <IN> input type (type read from this server)
 * @param <OUT> output type (type written to this server)
 * @param <CHANNEL> channel type
 */
public interface Server<IN, OUT, CHANNEL extends Channel<IN,OUT>> extends RunnableService {
	/**
	 * 
	 * @param handler
	 * @return self
	 */
	default Server<IN, OUT, CHANNEL> onConnect(Consumer<CHANNEL> handler) {
		return onConnect(channel -> {
			handler.accept(channel);
			return true;
		});
	}
	/**
	 * Similar to {@link #onConnect(Consumer)}, but if the handler returns false, it will not
	 * receive any more events.
	 * @param handler
	 * @return self
	 */
	Server<IN, OUT, CHANNEL> onConnect(Predicate<CHANNEL> handler);
	/**
	 * Whether all channels from this server are guaranteed to be secure, usually through implementing
	 * some form of encryption, such as TLS.<br/>
	 * Determining whether or not a server is secure is a holistic process;
	 * a TCP server using SSLv3 should return false due to SSL's vulnerabilities, but
	 * a 'server' that is reading/writing to a file that is unencrypted on a user's
	 * private directory should return true. Because there are many protocols and encryption
	 * and authentication processes, implementations, or at least extending interaces should provide
	 * methods for handlers to determine the security of the channel.<br/>
	 * Also, note that this method only returns true IFF ALL possible channels generated by this server
	 * offer the standard of security.
	 * @return whether the server is secure
	 */
	boolean isSecure();
	/**
	 * Gracefully shutdown the server, such that it will not accept any new incoming requests,
	 * and will close connections that are not actively being used. This method will
	 * fail quietly and return <code>false</code> if the server is not currently running.<br/>
	 * If the server is able to shutdown immediately, then it should do so and return <code>true</code>.
	 * Calls to {@link #getState()} while the server is shutting down should return
	 * {@link com.divisors.projectcuttlefish.httpserver.api.RunnableServiceState#STOPPING STOPPING}.
	 * <p>
	 * While the server is shutting down, further calls to this method SHOULD NOT do anything,
	 * but return true.
	 * </p> 
	 * @return if the server was queued for shutdown.
	 * @see #shutdown(Duration)
	 * @see #shutdownNow()
	 */
	@Override
	boolean shutdown();
	/**
	 * Like {@link #shutdown()}, but will block for up to <var>timeout</var> to wait for the server to shut down.
	 * @param timeout
	 * @return whether the server was shut down
	 * @throws InterruptedException 
	 * @see #shutdown()
	 * @see #shutdownNow()
	 */
	@Override
	boolean shutdown(Duration timeout) throws InterruptedException;
	/**
	 * Immediately shuts down the server, closing all open channels, and blocking the current
	 * thread until it is shut down. While this method is blocking, {@link #isShuttingDown()} SHOULD
	 * return <code>true</code>.<br/>
	 * If the server was not running at the time of the method call, it should silently fail by returning
	 * <code>false</code>.
	 * @return success in stopping down the server
	 * @throws Exception if there was a problem shutting down the server
	 * @see #shutdown()
	 * @see #shutdownNow()
	 */
	@Override
	boolean shutdownNow() throws Exception;
	/**
	 * Whether the server is currently shutting down. When it is shutting down,
	 * no new channels should be opened, and idle channels should be closed gracefully.
	 * @return whether it is currently shutting down
	 * @see #init()
	 * @see #start()
	 * @see #shutdown()
	 * @see #shutdownNow()
	 * @see #destroy()
	 */
	ServiceState getState();
}
